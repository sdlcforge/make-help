package target

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/sdlcforge/make-help/internal/format"
	"github.com/sdlcforge/make-help/internal/model"
)

// GeneratorConfig holds configuration for help file generation.
type GeneratorConfig struct {
	// Options for rendering
	KeepOrderCategories bool
	KeepOrderTargets    bool
	CategoryOrder       []string
	DefaultCategory     string
	IncludeTargets      []string
	IncludeAllPhony     bool

	// UseColor controls whether ANSI color codes are embedded in the output
	UseColor bool

	// Makefiles is the list of discovered Makefiles for dependency tracking
	Makefiles []string

	// HelpModel is the built model to render
	HelpModel *model.HelpModel

	// MakefileDir is the directory containing the main Makefile (for relative paths)
	MakefileDir string
}

// GenerateHelpFile creates the complete help Makefile content with static help text.
// The generated file includes:
//   - Static help content embedded in @echo statements
//   - Individual help-<target> targets with detailed information
//   - Auto-regeneration target that rebuilds when source Makefiles change
func GenerateHelpFile(config *GeneratorConfig) (string, error) {
	var buf strings.Builder

	// Create renderer with color configuration
	renderer := format.NewRenderer(config.UseColor)

	// Header
	buf.WriteString("# Generated by make-help. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("# Regenerate with: make-help%s\n",
		buildRegenerateFlags(config)))
	buf.WriteString("\n")

	// Variables
	buf.WriteString("MAKE_HELP_DIR := $(dir $(lastword $(MAKEFILE_LIST)))\n")

	// Makefile dependencies
	relativeMakefiles := relativizeMakefilePaths(config.Makefiles, config.MakefileDir)
	if len(relativeMakefiles) > 0 {
		buf.WriteString(fmt.Sprintf("MAKE_HELP_MAKEFILES := %s\n", strings.Join(relativeMakefiles, " ")))
	}
	buf.WriteString("\n")

	// Main help target with static content
	buf.WriteString(".PHONY: help\n")
	buf.WriteString("## Displays help for available targets.\n")
	buf.WriteString("help: $(MAKE_HELP_DIR)help.mk\n")

	// Render help content
	helpLines, err := renderer.RenderForMakefile(config.HelpModel)
	if err != nil {
		return "", fmt.Errorf("failed to render help content: %w", err)
	}

	for _, line := range helpLines {
		buf.WriteString(fmt.Sprintf("\t@echo \"%s\"\n", line))
	}

	// Generate help-<target> targets for each documented target
	for _, category := range config.HelpModel.Categories {
		for _, target := range category.Targets {
			buf.WriteString("\n")
			buf.WriteString(fmt.Sprintf(".PHONY: help-%s\n", target.Name))
			buf.WriteString(fmt.Sprintf("help-%s: $(MAKE_HELP_DIR)help.mk\n", target.Name))

			detailedLines := renderer.RenderDetailedForMakefile(&target)
			for _, line := range detailedLines {
				buf.WriteString(fmt.Sprintf("\t@echo \"%s\"\n", line))
			}
		}
	}

	// Auto-regeneration target
	buf.WriteString("\n")
	buf.WriteString(generateRegenerationTarget(config))

	return buf.String(), nil
}

// buildRegenerateFlags builds the flag string for the regeneration comment.
// This shows users how to regenerate the help file.
func buildRegenerateFlags(config *GeneratorConfig) string {
	var flags []string

	// Add --no-color if colors are disabled
	if !config.UseColor {
		flags = append(flags, "--no-color")
	}

	// Add ordering flags
	if config.KeepOrderCategories {
		flags = append(flags, "--keep-order-categories")
	}
	if config.KeepOrderTargets {
		flags = append(flags, "--keep-order-targets")
	}

	// Add category order
	if len(config.CategoryOrder) > 0 {
		flags = append(flags, fmt.Sprintf("--category-order %s", strings.Join(config.CategoryOrder, ",")))
	}

	// Add default category
	if config.DefaultCategory != "" {
		flags = append(flags, fmt.Sprintf("--default-category %s", config.DefaultCategory))
	}

	// Add include targets
	if len(config.IncludeTargets) > 0 {
		for _, target := range config.IncludeTargets {
			flags = append(flags, fmt.Sprintf("--include-target %s", target))
		}
	}

	// Add include all phony
	if config.IncludeAllPhony {
		flags = append(flags, "--include-all-phony")
	}

	if len(flags) == 0 {
		return ""
	}
	return " " + strings.Join(flags, " ")
}

// generateRegenerationTarget creates the auto-regeneration target.
// This target rebuilds the help file when source Makefiles change.
func generateRegenerationTarget(config *GeneratorConfig) string {
	var buf strings.Builder

	// Build flags to pass to regeneration command (same flags used for original generation)
	flags := buildRegenerateFlags(config)

	buf.WriteString("# Auto-regenerate help when source Makefiles change\n")
	buf.WriteString("$(MAKE_HELP_DIR)help.mk: $(MAKE_HELP_MAKEFILES)\n")
	buf.WriteString(fmt.Sprintf("\t@make-help --makefile-path $(MAKE_HELP_DIR)Makefile%s || \\\n", flags))
	buf.WriteString(fmt.Sprintf("\t npx make-help --makefile-path $(MAKE_HELP_DIR)Makefile%s || \\\n", flags))
	buf.WriteString("\t echo \"make-help not found; install with 'go install github.com/sdlcforge/make-help/cmd/make-help@latest' or 'npm install -g make-help'\"\n")

	return buf.String()
}

// relativizeMakefilePaths converts absolute Makefile paths to relative paths using $(MAKE_HELP_DIR).
// This ensures the generated help.mk works regardless of where it's included from.
func relativizeMakefilePaths(makefiles []string, makefileDir string) []string {
	var relative []string

	for _, mf := range makefiles {
		// Clean both paths for proper comparison
		cleanMF := filepath.Clean(mf)
		cleanDir := filepath.Clean(makefileDir)

		// Try to make relative to makefileDir
		relPath, err := filepath.Rel(cleanDir, cleanMF)
		if err != nil {
			// If we can't make it relative, use the absolute path
			// This shouldn't happen in normal usage
			relative = append(relative, cleanMF)
			continue
		}

		// Convert to $(MAKE_HELP_DIR) relative path
		// Use forward slashes for Makefile compatibility
		relPath = filepath.ToSlash(relPath)
		relative = append(relative, "$(MAKE_HELP_DIR)"+relPath)
	}

	return relative
}

// generateHelpTarget is a DEPRECATED compatibility wrapper for add.go.
// It will be removed in Phase 4/5 when the orchestration layer is updated.
// This function cannot generate proper static help without a HelpModel,
// so it returns a minimal placeholder that directs users to use the new workflow.
func generateHelpTarget(config *Config) string {
	var buf strings.Builder

	buf.WriteString("# Generated by make-help. DO NOT EDIT.\n")
	buf.WriteString("# This is a placeholder - regenerate with updated make-help for static content.\n")
	buf.WriteString("\n")
	buf.WriteString("MAKE_HELP_DIR := $(dir $(lastword $(MAKEFILE_LIST)))\n")
	buf.WriteString("\n")
	buf.WriteString(".PHONY: help\n")
	buf.WriteString("## Displays help for available targets.\n")
	buf.WriteString("help:\n")
	buf.WriteString("\t@echo \"Help generation is being upgraded. Please run 'make-help' to regenerate.\"\n")

	return buf.String()
}

// GenerateHelpFileDeprecated is a TEMPORARY compatibility function for Phase 3.
// This maintains the old signature until Phase 4 updates the CLI layer.
// It creates a minimal HelpModel from the provided targets.
// WARNING: This will be REMOVED in Phase 4. Do not use in new code.
func GenerateHelpFileDeprecated(config *GeneratorConfig, targets []string) string {
	// Create a minimal HelpModel with uncategorized targets
	helpModel := &model.HelpModel{
		Categories: []model.Category{
			{
				Name:    "",
				Targets: make([]model.Target, len(targets)),
			},
		},
	}

	for i, targetName := range targets {
		helpModel.Categories[0].Targets[i] = model.Target{
			Name:          targetName,
			Documentation: []string{"Target documentation (regenerate to populate)"},
		}
	}

	// Create a new config with the HelpModel
	newConfig := &GeneratorConfig{
		KeepOrderCategories: config.KeepOrderCategories,
		KeepOrderTargets:    config.KeepOrderTargets,
		CategoryOrder:       config.CategoryOrder,
		DefaultCategory:     config.DefaultCategory,
		IncludeTargets:      config.IncludeTargets,
		IncludeAllPhony:     config.IncludeAllPhony,
		UseColor:            true, // Default to color for now
		Makefiles:           []string{"Makefile"},
		MakefileDir:         ".",
		HelpModel:           helpModel,
	}

	result, err := GenerateHelpFile(newConfig)
	if err != nil {
		// Fallback to a basic error message
		return fmt.Sprintf("# Error generating help: %v\n", err)
	}

	return result
}
