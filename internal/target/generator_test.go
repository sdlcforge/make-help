package target

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateHelpFile_Basic(t *testing.T) {
	config := &GeneratorConfig{}
	targets := []string{"build", "test"}

	result := GenerateHelpFile(config, targets)

	// Check header
	if !strings.Contains(result, "# Generated by make-help. DO NOT EDIT.") {
		t.Error("Missing header comment")
	}
	if !strings.Contains(result, "# Regenerate with: make-help --create-help-target") {
		t.Error("Missing regeneration command")
	}

	// Check variables
	if !strings.Contains(result, "MAKE_HELP_DIR := $(dir $(lastword $(MAKEFILE_LIST)))") {
		t.Error("Missing MAKE_HELP_DIR self-referential variable")
	}
	if !strings.Contains(result, "GOBIN ?= $(MAKE_HELP_DIR).bin") {
		t.Error("Missing GOBIN conditional assignment with MAKE_HELP_DIR")
	}
	if !strings.Contains(result, "MAKE_HELP_BIN := $(GOBIN)/make-help") {
		t.Error("Missing MAKE_HELP_BIN variable")
	}
	if !strings.Contains(result, "MAKE_HELP_OPTS :=") {
		t.Error("Missing MAKE_HELP_OPTS variable")
	}
	if !strings.Contains(result, "MAKE_HELP_CMD := $(MAKE_HELP_BIN) $(MAKE_HELP_OPTS)") {
		t.Error("Missing MAKE_HELP_CMD variable")
	}

	// Check binary install target (should NOT be .PHONY)
	if !strings.Contains(result, "$(MAKE_HELP_BIN):") {
		t.Error("Missing binary install target")
	}
	if !strings.Contains(result, "GOBIN=$(abspath $(GOBIN)) go install github.com/sdlcforge/make-help/cmd/make-help@latest") {
		t.Error("Missing or incorrect go install command")
	}
	// Ensure binary target is NOT .PHONY
	lines := strings.Split(result, "\n")
	for i, line := range lines {
		if strings.Contains(line, "$(MAKE_HELP_BIN):") {
			// Check previous line is not .PHONY
			if i > 0 && strings.Contains(lines[i-1], ".PHONY") && strings.Contains(lines[i-1], "$(MAKE_HELP_BIN)") {
				t.Error("Binary install target should NOT be .PHONY")
			}
		}
	}

	// Check main help target
	if !strings.Contains(result, ".PHONY: help") {
		t.Error("help target should be .PHONY")
	}
	if !strings.Contains(result, "# Displays help summary.") {
		t.Error("Missing help documentation comment")
	}
	if !strings.Contains(result, "help: $(MAKE_HELP_BIN)") {
		t.Error("help target should depend on MAKE_HELP_BIN")
	}
	if !strings.Contains(result, "@$(MAKE_HELP_CMD)") {
		t.Error("help target should invoke MAKE_HELP_CMD")
	}

	// Check help-<target> targets
	if !strings.Contains(result, ".PHONY: help-build") {
		t.Error("help-build should be .PHONY")
	}
	if !strings.Contains(result, "help-build: $(MAKE_HELP_BIN)") {
		t.Error("help-build should depend on MAKE_HELP_BIN")
	}
	if !strings.Contains(result, "@$(MAKE_HELP_CMD) --target build") {
		t.Error("help-build should invoke MAKE_HELP_CMD with --target")
	}

	if !strings.Contains(result, ".PHONY: help-test") {
		t.Error("help-test should be .PHONY")
	}
	if !strings.Contains(result, "help-test: $(MAKE_HELP_BIN)") {
		t.Error("help-test should depend on MAKE_HELP_BIN")
	}
	if !strings.Contains(result, "@$(MAKE_HELP_CMD) --target test") {
		t.Error("help-test should invoke MAKE_HELP_CMD with --target")
	}
}

func TestGenerateHelpFile_WithVersion(t *testing.T) {
	config := &GeneratorConfig{
		Version: "v1.2.3",
	}
	targets := []string{}

	result := GenerateHelpFile(config, targets)

	// Check version in go install command
	if !strings.Contains(result, "go install github.com/sdlcforge/make-help/cmd/make-help@v1.2.3") {
		t.Error("Version should be used in go install command")
	}

	// Check version in regeneration command
	if !strings.Contains(result, "--version v1.2.3") {
		t.Error("Version should appear in regeneration command")
	}
}

func TestGenerateHelpFile_WithAllOptions(t *testing.T) {
	config := &GeneratorConfig{
		KeepOrderCategories: true,
		KeepOrderTargets:    true,
		CategoryOrder:       []string{"Build", "Test", "Deploy"},
		DefaultCategory:     "Misc",
		IncludeTargets:      []string{"lint", "fmt"},
		IncludeAllPhony:     true,
		Version:             "v2.0.0",
	}
	targets := []string{"build"}

	result := GenerateHelpFile(config, targets)

	// Check all options in MAKE_HELP_OPTS
	if !strings.Contains(result, "--keep-order-categories") {
		t.Error("Missing --keep-order-categories")
	}
	if !strings.Contains(result, "--keep-order-targets") {
		t.Error("Missing --keep-order-targets")
	}
	if !strings.Contains(result, "--category-order Build,Test,Deploy") {
		t.Error("Missing or incorrect --category-order")
	}
	if !strings.Contains(result, "--default-category Misc") {
		t.Error("Missing --default-category")
	}
	if !strings.Contains(result, "--include-target lint") {
		t.Error("Missing --include-target lint")
	}
	if !strings.Contains(result, "--include-target fmt") {
		t.Error("Missing --include-target fmt")
	}
	if !strings.Contains(result, "--include-all-phony") {
		t.Error("Missing --include-all-phony")
	}

	// Check version
	if !strings.Contains(result, "go install github.com/sdlcforge/make-help/cmd/make-help@v2.0.0") {
		t.Error("Version should be v2.0.0")
	}

	// Check regeneration command includes all flags
	if !strings.Contains(result, "# Regenerate with: make-help --create-help-target --version v2.0.0") {
		t.Error("Regeneration command should include version")
	}
}

func TestGenerateHelpFile_MultipleTargets(t *testing.T) {
	config := &GeneratorConfig{}
	targets := []string{"build", "test", "clean", "deploy"}

	result := GenerateHelpFile(config, targets)

	// Check all help-<target> targets exist
	expectedTargets := []string{"build", "test", "clean", "deploy"}
	for _, target := range expectedTargets {
		phonyDecl := ".PHONY: help-" + target
		targetDecl := "help-" + target + ": $(MAKE_HELP_BIN)"
		targetCmd := "@$(MAKE_HELP_CMD) --target " + target

		if !strings.Contains(result, phonyDecl) {
			t.Errorf("Missing .PHONY declaration for help-%s", target)
		}
		if !strings.Contains(result, targetDecl) {
			t.Errorf("Missing target declaration for help-%s", target)
		}
		if !strings.Contains(result, targetCmd) {
			t.Errorf("Missing command for help-%s", target)
		}
	}
}

func TestGenerateHelpFile_NoTargets(t *testing.T) {
	config := &GeneratorConfig{
		DefaultCategory: "Tasks",
	}
	targets := []string{}

	result := GenerateHelpFile(config, targets)

	// Should still have base structure
	if !strings.Contains(result, "GOBIN ?= $(MAKE_HELP_DIR).bin") {
		t.Error("Should have GOBIN variable with MAKE_HELP_DIR")
	}
	if !strings.Contains(result, ".PHONY: help") {
		t.Error("Should have help target")
	}

	// Should not have any help-<target> entries
	if strings.Contains(result, "help-") && !strings.Contains(result, "make-help") {
		t.Error("Should not have help-<target> entries when targets is empty")
	}
}

func TestGenerateHelpFile_ValidMakefile(t *testing.T) {
	// Skip if make is not available
	if _, err := exec.LookPath("make"); err != nil {
		t.Skip("make command not available")
	}

	config := &GeneratorConfig{
		DefaultCategory: "General",
		IncludeTargets:  []string{"lint"},
	}
	targets := []string{"build", "test"}

	result := GenerateHelpFile(config, targets)

	// Write to temp file
	tmpDir := t.TempDir()
	makefilePath := filepath.Join(tmpDir, "Makefile")
	if err := os.WriteFile(makefilePath, []byte(result), 0644); err != nil {
		t.Fatalf("Failed to write temp Makefile: %v", err)
	}

	// Run make -n to validate syntax
	cmd := exec.Command("make", "-n", "-f", makefilePath, "help")
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Errorf("Generated Makefile has syntax errors:\n%s\nError: %v", output, err)
	}
}

func TestBuildMakeHelpOpts(t *testing.T) {
	tests := []struct {
		name     string
		config   *GeneratorConfig
		expected string
	}{
		{
			name:     "empty config",
			config:   &GeneratorConfig{},
			expected: "",
		},
		{
			name: "keep order categories only",
			config: &GeneratorConfig{
				KeepOrderCategories: true,
			},
			expected: "--keep-order-categories",
		},
		{
			name: "keep order targets only",
			config: &GeneratorConfig{
				KeepOrderTargets: true,
			},
			expected: "--keep-order-targets",
		},
		{
			name: "category order",
			config: &GeneratorConfig{
				CategoryOrder: []string{"Build", "Test"},
			},
			expected: "--category-order Build,Test",
		},
		{
			name: "default category",
			config: &GeneratorConfig{
				DefaultCategory: "Misc",
			},
			expected: "--default-category Misc",
		},
		{
			name: "include targets",
			config: &GeneratorConfig{
				IncludeTargets: []string{"lint", "fmt"},
			},
			expected: "--include-target lint --include-target fmt",
		},
		{
			name: "include all phony",
			config: &GeneratorConfig{
				IncludeAllPhony: true,
			},
			expected: "--include-all-phony",
		},
		{
			name: "multiple options",
			config: &GeneratorConfig{
				KeepOrderCategories: true,
				DefaultCategory:     "Tasks",
				IncludeAllPhony:     true,
			},
			expected: "--keep-order-categories --default-category Tasks --include-all-phony",
		},
		{
			name: "all options",
			config: &GeneratorConfig{
				KeepOrderCategories: true,
				KeepOrderTargets:    true,
				CategoryOrder:       []string{"A", "B"},
				DefaultCategory:     "C",
				IncludeTargets:      []string{"x", "y"},
				IncludeAllPhony:     true,
			},
			expected: "--keep-order-categories --keep-order-targets --category-order A,B --default-category C --include-target x --include-target y --include-all-phony",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := buildMakeHelpOpts(tt.config)
			if result != tt.expected {
				t.Errorf("buildMakeHelpOpts() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestBuildRegenerateFlags(t *testing.T) {
	tests := []struct {
		name     string
		config   *GeneratorConfig
		expected string
	}{
		{
			name:     "empty config",
			config:   &GeneratorConfig{},
			expected: "",
		},
		{
			name: "version only",
			config: &GeneratorConfig{
				Version: "v1.0.0",
			},
			expected: " --version v1.0.0",
		},
		{
			name: "options only",
			config: &GeneratorConfig{
				DefaultCategory: "Misc",
			},
			expected: " --default-category Misc",
		},
		{
			name: "version and options",
			config: &GeneratorConfig{
				Version:             "v2.0.0",
				KeepOrderCategories: true,
				DefaultCategory:     "Tasks",
			},
			expected: " --version v2.0.0 --keep-order-categories --default-category Tasks",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := buildRegenerateFlags(tt.config)
			if result != tt.expected {
				t.Errorf("buildRegenerateFlags() = %q, want %q", result, tt.expected)
			}
		})
	}
}
