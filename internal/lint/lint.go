package lint

import (
	"fmt"
	"sort"
	"sync"

	"github.com/sdlcforge/make-help/internal/model"
)

// Severity represents the severity level of a lint warning.
type Severity string

const (
	// SeverityWarning indicates a potential issue that should be reviewed.
	SeverityWarning Severity = "warning"
)

// Warning represents a single lint issue found during analysis.
type Warning struct {
	// File is the path to the Makefile where the issue was found.
	File string

	// Line is the line number where the issue occurs (0 if not applicable).
	Line int

	// Severity is the severity level of this warning.
	Severity Severity

	// CheckName identifies which check produced this warning (for sorting).
	CheckName string

	// Message is a human-readable description of the issue.
	Message string

	// Context provides additional context (e.g., the problematic line content).
	Context string

	// Fixable indicates whether this warning can be automatically fixed.
	Fixable bool
}

// TargetLocation holds the source file and line number where a target is defined.
type TargetLocation struct {
	File string
	Line int
}

// CheckContext provides all data needed by lint checks.
type CheckContext struct {
	// HelpModel contains the parsed and built help model.
	HelpModel *model.HelpModel

	// MakefilePath is the resolved path to the main Makefile being checked.
	MakefilePath string

	// PhonyTargets maps target names to their .PHONY status.
	PhonyTargets map[string]bool

	// Dependencies maps target names to their prerequisite targets.
	Dependencies map[string][]string

	// HasRecipe maps target names to whether they have a recipe.
	HasRecipe map[string]bool

	// DocumentedTargets contains the set of documented target names.
	DocumentedTargets map[string]bool

	// Aliases contains the set of all alias names (explicit and implicit).
	Aliases map[string]bool

	// GeneratedHelpTargets contains target names generated by make-help.
	// These are excluded from undocumented phony warnings.
	// Includes: "help", "update-help", and "help-<target>" for each documented target.
	GeneratedHelpTargets map[string]bool

	// TargetLocations maps target names to their source file and line number.
	// This is populated from parsed Makefiles and used to provide line numbers
	// in warnings for targets discovered via make but not in the help model.
	TargetLocations map[string]TargetLocation

	// NotAliasTargets contains targets marked with !notalias directive.
	// Used to detect redundant !notalias warnings.
	NotAliasTargets map[string]bool
}

// CheckFunc is a function that performs a specific lint check.
// It examines the CheckContext and returns a slice of warnings.
type CheckFunc func(ctx *CheckContext) []Warning

// LintResult contains the aggregated results of all lint checks.
type LintResult struct {
	// Warnings contains all lint warnings found, sorted by file and line.
	Warnings []Warning

	// HasWarnings returns true if any warnings were found.
	HasWarnings bool
}

// checkResult holds warnings from a single check with its fixability info.
type checkResult struct {
	warnings []Warning
	fixable  bool
}

// Lint runs all registered checks on the provided context in parallel using goroutines
// and returns the combined results.
func Lint(ctx *CheckContext, checks []Check) *LintResult {
	// Use a channel to collect warnings from all goroutines
	resultsChan := make(chan checkResult, len(checks))

	// Use a WaitGroup to wait for all checks to complete
	var wg sync.WaitGroup

	// Launch each check in its own goroutine
	for _, check := range checks {
		wg.Add(1)
		go func(c Check) {
			defer wg.Done()
			warnings := c.CheckFunc(ctx)
			resultsChan <- checkResult{
				warnings: warnings,
				fixable:  c.FixFunc != nil,
			}
		}(check)
	}

	// Close channel after all goroutines complete
	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	// Collect all warnings from the channel
	var allWarnings []Warning
	for result := range resultsChan {
		// Mark warnings as fixable if the check has a FixFunc
		for i := range result.warnings {
			result.warnings[i].Fixable = result.fixable
		}
		allWarnings = append(allWarnings, result.warnings...)
	}

	// Sort warnings by file, line number, then check name for consistent output
	sort.Slice(allWarnings, func(i, j int) bool {
		if allWarnings[i].File != allWarnings[j].File {
			return allWarnings[i].File < allWarnings[j].File
		}
		if allWarnings[i].Line != allWarnings[j].Line {
			return allWarnings[i].Line < allWarnings[j].Line
		}
		return allWarnings[i].CheckName < allWarnings[j].CheckName
	})

	return &LintResult{
		Warnings:    allWarnings,
		HasWarnings: len(allWarnings) > 0,
	}
}

// CollectFixes generates Fix objects for all fixable warnings.
func CollectFixes(checks []Check, warnings []Warning) []Fix {
	// Build check lookup by name
	checkMap := make(map[string]Check)
	for _, check := range checks {
		checkMap[check.Name] = check
	}

	var fixes []Fix
	for _, w := range warnings {
		if !w.Fixable {
			continue
		}

		check, ok := checkMap[w.CheckName]
		if !ok || check.FixFunc == nil {
			continue
		}

		fix := check.FixFunc(w)
		if fix != nil {
			fixes = append(fixes, *fix)
		}
	}

	return fixes
}

// FormatWarning formats a single warning in compiler-style format.
// Format: file:line: severity: message
func FormatWarning(w Warning) string {
	if w.Line > 0 {
		msg := fmt.Sprintf("%s:%d: %s: %s", w.File, w.Line, w.Severity, w.Message)
		if w.Context != "" {
			msg += fmt.Sprintf("\n  | %s", w.Context)
		}
		return msg
	}
	// No line number available
	msg := fmt.Sprintf("%s: %s: %s", w.File, w.Severity, w.Message)
	if w.Context != "" {
		msg += fmt.Sprintf("\n  | %s", w.Context)
	}
	return msg
}
